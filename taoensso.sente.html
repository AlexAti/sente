<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.sente documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Sente 0.8.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="taoensso.sente.html"><span>taoensso.sente</span></a></li><li><a href="taoensso.sente.utils.html"><span>taoensso.sente.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.sente.html#var-cb-success%3F"><span>cb-success?</span></a></li><li><a href="taoensso.sente.html#var-event-msg%3F"><span>event-msg?</span></a></li><li><a href="taoensso.sente.html#var-event%3F"><span>event?</span></a></li><li><a href="taoensso.sente.html#var-make-channel-socket%21"><span>make-channel-socket!</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.sente documentation</h2><pre class="doc">Channel sockets. Otherwise known as The Shiz.

    Protocol  | client&gt;server | client&gt;server + ack/reply | server&gt;clientS[1] push
  * WebSockets:       ✓              [2]                          ✓  ; [3]
  * Ajax:            [4]              ✓                          [5] ; [3]

  [1] All of a user's (uid's) connected clients (browser tabs, devices, etc.).
  [2] Emulate with cb-uuid wrapping.
  [3] By uid only (=&gt; logged-in users only).
  [4] Emulate with dummy-cb wrapping.
  [5] Emulate with long-polling against uid (=&gt; logged-in users only).

Special messages (implementation detail):
  * cb replies: :chsk/closed, :chsk/timeout, :chsk/error.
  * client-side events:
      [:chsk/handshake &lt;#{:ws :ajax}&gt;],
      [:chsk/ping      &lt;#{:ws :ajax}&gt;], ; Though no :ajax ping
      [:chsk/state [&lt;#{:open :first-open :closed}&gt; &lt;#{:ws :ajax}]],
      [:chsk/recv  &lt;`server&gt;client`-event&gt;]. ; Async event

  * server-side events:
     [:chsk/bad-edn &lt;edn&gt;],
     [:chsk/bad-event &lt;chsk-event&gt;],
     [:chsk/uidport-open  &lt;#{:ws :ajax}&gt;],
     [:chsk/uidport-close &lt;#{:ws :ajax}&gt;].

  * event wrappers: {:chsk/clj &lt;clj&gt; :chsk/dummy-cb? true} (for [2]),
                    {:chsk/clj &lt;clj&gt; :chsk/cb-uuid &lt;uuid&gt;} (for [4]).

Implementation notes:
  * A server&gt;client w/cb mechanism would be possible BUT:
    * No fundamental use cases. We can always simulate as server&gt;client w/o cb,
      client&gt;server w or w/o cb.
    * Would yield a significantly more complex code base.
    * Cb semantic is fundamentally incongruous with server&gt;client since
      multiple clients may be connected simultaneously for a single uid.

General-use notes:
  * Single HTTP req+session persists over entire chsk session but cannot
    modify sessions! Use standard a/sync HTTP Ring req/resp for logins, etc.
  * Easy to wrap standard HTTP Ring resps for transport over chsks. Prefer
    this approach to modifying handlers (better portability).

Multiple clients (browser tabs, devices, etc.):
  * client&gt;server + ack/reply: sends always to _single_ client. Note that an
    optional _multi_ client reply API wouldn't make sense (we're using a cb).
  * server&gt;clientS push: sends always to _all_ clients.
  * Applications will need to be careful about which method is preferable, and
    when.</pre><div class="public" id="var-cb-success%3F"><h3>cb-success?</h3><div class="usage"><code>(cb-success? cb-reply)</code></div><pre class="doc"></pre></div><div class="public" id="var-event-msg%3F"><h3>event-msg?</h3><div class="usage"><code>(event-msg? x)</code></div><pre class="doc">Valid {:client-uuid _ :ring-req _ :event _ :?reply-fn _} form?
</pre></div><div class="public" id="var-event%3F"><h3>event?</h3><div class="usage"><code>(event? x)</code></div><pre class="doc">Valid [ev-id ?ev-data] form?
</pre></div><div class="public" id="var-make-channel-socket%21"><h3>make-channel-socket!</h3><div class="usage"><code>(make-channel-socket! &amp; [{:keys [recv-buf-or-n], :or {recv-buf-or-n (async/sliding-buffer 1000)}}])</code></div><pre class="doc">Returns `{:keys [ch-recv send-fn ajax-post-fn ajax-get-or-ws-handshake-fn]}`.

ch-recv - core.async channel ; For server-side chsk request router, will
                             ; receive `event-msg`s from clients.
send-fn - (fn [user-id ev])   ; For server&gt;clientS push
ajax-post-fn                - (fn [ring-req]) ; For Ring POST, chsk URL
ajax-get-or-ws-handshake-fn - (fn [ring-req]) ; For Ring GET, chsk URL (+CSRF)</pre></div></div></body></html>